#pragma once

// https://modoocode.com/271

//-----------------------------------------------------------------------------
// 캐시
//-----------------------------------------------------------------------------
namespace section1
{
// CPU와 컴퓨터 메모리인 RAM은 물리적으로 떨어져 있어서
// 메모리로부터 데이터를 읽어 오기 위해서는 시간이 오래 걸린다.
// 예를 들어,
// 메모리로부터 데이터를 읽어오는데 42 사이클이 걸리고
// 덧셈 연산은 1사이클이 걸린다.
// 그래서 읽어오는 시간을 기다리면 42번 덧셈연산을 놓친다.
//
// CPU 칩 안에 있는 작은 메모리인 캐시 Cache가 존재한다.
// 물리적으로 CPU와 붙어 있기 때문에 읽기/쓰기 속도가 훨씬 빠르다.
//
// 예를 들어,
// 코어마다 공유하지 않는 L1,L2 캐시가 존재한다.
// L1 캐시 : 32KB,			r/w 속도 = 4 사이클
// L2 캐시 : 256KB			r/w 속도 = 12 사이클
// 공유하는 L3 캐시 : 8MB		r/w 속도 = 36 사이클
//
// CPU가 특정한 주소에 있는 데이터에 접근한다면,
// L1, L2, L3, 메모리 순으로 데이터를 확인한다.
// 데이터를 캐시에서 가져오면 Cache hit 라고 한다.
// 데이터를 메모리까지 가서 가져오면 Cache miss 라고 한다.
//
// CPU가 메모리를 읽으면 캐시에 저장해놓는다.
// 만약 캐시가 다 찼다면 특정한 방식에 따라 처리한다.
// 특정한 방식은 CPU 마다 다르다.
// 대표적인 예로 Least Recently Used (LRU) Cache에 새로운 캐시를 기록하는 방식이
// 있다. (가장 오래된 캐시를 새로운 캐시로 덮어씌운다.)
//
// 예를 들어, 캐시가 1KB 크기이고 LRU 방식을 사용하는 CPU에 대해서 다음과 같다.
void cache_miss()
{
    for (int i = 0; i < 10000; ++i) {
        for (int j = 0; j < 10000; ++j) {
            // s += data[j];
        }
    }
    // j = 256이 되었을 때, data[0]은 캐시에서 사라진다.
    // 다음 루프에서 data[0]은 캐시에 존재하지 않으므로 메모리에서 가져온다.
}

void cache_hit()
{
    for (int j = 0; j < 10000; j++) {
        for (int i = 0; i < 10000; i++) {
            // s += data[j];
        }
        // 처음 data[0]에 접근할 때 메모리에서 가져온다.
        // 이후 data[0]은 모두 캐시에서 가져온다.
    }
}
}
